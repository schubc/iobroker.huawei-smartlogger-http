{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.3.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\n\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios';\nimport { CookieJar } from 'tough-cookie';\nimport querystring from \"querystring\";\nlet adapter: ioBroker.Adapter;\nlet cookieJar = new CookieJar();\nlet token: null=null;\nlet timerId: NodeJS.Timeout | undefined;\n\nconst axiosInstance = axios.create({\n    httpsAgent: new (require('https').Agent)({\n        rejectUnauthorized: false\n    }),\n    withCredentials: true\n});\n\naxiosInstance.interceptors.request.use((config: AxiosRequestConfig) => {\n    return new Promise((resolve, reject) => {\n        cookieJar.getCookies(config.url!, (err: any, cookies: any[]) => {\n            if (err) {\n                reject(err);\n            }\n            // @ts-ignore\n            config.headers['Cookie'] = cookies.join('; ');\n            // @ts-ignore\n            resolve(config);\n        });\n    });\n});\n\naxiosInstance.interceptors.response.use((response: AxiosResponse) => {\n    const setCookie = response.headers['set-cookie'];\n\n    if (setCookie) {\n        cookieJar.setCookieSync(setCookie[0], response.config.url!);\n    }\n\n    return response;\n});\n\n\n/**\n * Starts the adapter instance\n */\nfunction startAdapter(options: Partial<utils.AdapterOptions> = {}): ioBroker.Adapter {\n    // Create the adapter and define its methods\n    return adapter = utils.adapter({\n        // Default options\n        ...options,\n        // custom options\n        name: \"huawei-smartlogger-http\",\n\n        // The ready callback is called when databases are connected and adapter received configuration.\n        // start here!\n        ready: main, // Main method defined below for readability\n\n        // is called when adapter shuts down - callback has to be called under any circumstances!\n        unload: (callback) => {\n            try {\n                if(timerId) clearTimeout(timerId);\n\n                // Here you must clear all timeouts or intervals that may still be active\n                // clearTimeout(timeout1);\n                // clearTimeout(timeout2);\n                // ...\n                // clearInterval(interval1);\n\n                callback();\n            } catch (e) {\n                callback();\n            }\n        },\n\n\n        // If you need to accept messages in your adapter, uncomment the following block.\n        // /**\n        //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n        //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n        //  */\n        message: async (obj) => {\n            if (typeof obj === \"object\") {\n                if (obj.command === \"send\") {\n                    // e.g. send email or pushover or whatever\n                    adapter.log.info(\"send command\");\n                    let token = await getXhrToken()\n                    // Send response in callback if required\n                    if (obj.callback) adapter.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n                }\n            }\n        },\n    }\n    );\n}\n\nasync function main(): Promise<void> {\n\n    // Reset the connection indicator during startup\n    await adapter.setStateAsync(\"info.connection\", false, true);\n\n    await setStates(null)\n    await PollValues();\n}\n\n/**\n * Polls values asynchronously.\n *\n * @returns {Promise} Resolves when the polling is complete.\n */\nasync function PollValues() {\n    adapter.log.info(\"Pollvalues\");\n    const data = await getDataWithLogin();\n    await setStates(data);\n    if (adapter && adapter.config && adapter.config.interval > 0) {\n        // Save result of setTimeout to the global variable timerId\n        timerId = setTimeout(PollValues, adapter.config.interval * 1000);\n    } else {\n        console.log(\"NO INTERVAL\")\n    }\n}\n\n/**\n * Sets states based on the given data object.\n *\n * @param {object} data - The data object containing state values.\n * @return {undefined}\n */\nasync function setStates(data: any) {\n\n    if (adapter && adapter.config && Array.isArray(adapter.config.items)) {\n        for (const item of adapter.config.items) {\n\n            const itemId = item.id.toString();\n\n            if (data && data.hasOwnProperty(itemId)) {\n                let value;\n                if (item.type === 'number') {\n                    value = parseFloat(data[itemId]) * Math.pow(10, item.multiplier);\n                } else {\n                    value = data[itemId];\n                }\n                await adapter.setStateAsync(item.name, { val: value, ack: true });\n            } else {\n                await adapter.setObjectNotExistsAsync(item.name, {\n                    type: 'state',\n                    common: {\n                        name: item.name,\n                        type: item.type,\n                        role: 'value',\n                        read: true,\n                        write: true,\n                        unit: item.unit,\n                    },\n                    native: {},\n                });\n            }\n\n        }\n    }\n}\n\n/**\n * Retrieves data by authenticating with login credentials.\n *\n * @returns {Promise<Object|null>} - The retrieved data if successful, or null if unsuccessful.\n */\nasync function getDataWithLogin() {\n    let data= await getData()\n    if (!data) {\n        token=await getXhrToken()\n        data = await getData()\n        if(!data) return null\n    }\n    return data\n}\n/**\n * Gets the XHR token from the server.\n *\n * @returns {Promise<null>} A Promise that resolves to the XHR token or null if it couldn't be retrieved.\n */\nasync function getXhrToken(): Promise<null> {\n    try {\n\n        const url1 = 'https://' + adapter.config.adress + '/action/login';\n        const payload = {\n            langlist: 0,\n            usrname: adapter.config.username,\n            string: adapter.config.password\n        };\n        await axiosInstance.post(url1, querystring.stringify(payload), {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            }\n        });\n\n        const url2 = 'https://' + adapter.config.adress + '/js/csrf.jst';\n        const response = await axiosInstance.get(url2);\n        let regex = /token\\[\\\"value\\\"\\] = \\\"([0-9a-f]+)\\\";/;\n        const match = response.data.match(regex);\n\n        if (!match) {\n            return null;\n        }\n\n        return match[1];\n\n    } catch (error) {\n        console.error(error);\n        return null;\n    }\n}\n\n/**\n * Retrieves data from a remote server.\n *\n * @returns A Promise that resolves to an object containing key-value pairs, or null if there was an error.\n */\nasync function getData(): Promise<{[key: string]: string} | null> {\n    if (!token) {\n        await adapter.setStateAsync(\"info.connection\", false, true);\n        return null;\n    }\n\n    const url = 'https://' + adapter.config.adress + '/get_smartLog_equip_info.asp?type=4&para1=' + adapter.config.para1 + '&para2=' + adapter.config.para2 + '&para3=';\n\n    try {\n        const response: AxiosResponse = await axiosInstance.get(url, {\n            headers: {\n                'x-csrf-token': token,\n                'X-Requested-With': 'XMLHttpRequest'\n            }\n        });\n\n        if (response.status === 404) {\n            return null;\n        }\n\n        const regex = /\\|(\\d+)~([^|]+)/g;\n        let match = regex.exec(response.data);\n\n        const d: {[key: string]: string} = {};\n\n        while (match != null) {\n            d[match[1]] = match[2];\n            match = regex.exec(response.data);\n        }\n        await adapter.setStateAsync(\"info.connection\", true, true);\n        return d;\n    } catch (error) {\n        await adapter.setStateAsync(\"info.connection\", false, true);\n        console.error(error);\n        return null;\n    }\n}\n\n\nif (require.main !== module) {\n    // Export startAdapter in compact mode\n    module.exports = startAdapter;\n} else {\n    // otherwise start the instance directly\n    startAdapter();\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAMA,YAAuB;AAEvB,mBAAyD;AACzD,0BAA0B;AAC1B,yBAAwB;AACxB,IAAI;AACJ,IAAI,YAAY,IAAI,8BAAU;AAC9B,IAAI,QAAY;AAChB,IAAI;AAEJ,MAAM,gBAAgB,aAAAA,QAAM,OAAO;AAAA,EAC/B,YAAY,KAAK,QAAQ,OAAO,GAAE,MAAO;AAAA,IACrC,oBAAoB;AAAA,EACxB,CAAC;AAAA,EACD,iBAAiB;AACrB,CAAC;AAED,cAAc,aAAa,QAAQ,IAAI,CAAC,WAA+B;AACnE,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,cAAU,WAAW,OAAO,KAAM,CAAC,KAAU,YAAmB;AAC5D,UAAI,KAAK;AACL,eAAO,GAAG;AAAA,MACd;AAEA,aAAO,QAAQ,YAAY,QAAQ,KAAK,IAAI;AAE5C,cAAQ,MAAM;AAAA,IAClB,CAAC;AAAA,EACL,CAAC;AACL,CAAC;AAED,cAAc,aAAa,SAAS,IAAI,CAAC,aAA4B;AACjE,QAAM,YAAY,SAAS,QAAQ;AAEnC,MAAI,WAAW;AACX,cAAU,cAAc,UAAU,IAAI,SAAS,OAAO,GAAI;AAAA,EAC9D;AAEA,SAAO;AACX,CAAC;AAMD,SAAS,aAAa,UAAyC,CAAC,GAAqB;AAEjF,SAAO,UAAU,MAAM;AAAA,IAAQ;AAAA,MAE3B,GAAG;AAAA,MAEH,MAAM;AAAA,MAIN,OAAO;AAAA,MAGP,QAAQ,CAAC,aAAa;AAClB,YAAI;AACA,cAAG;AAAS,yBAAa,OAAO;AAQhC,mBAAS;AAAA,QACb,SAAS,GAAP;AACE,mBAAS;AAAA,QACb;AAAA,MACJ;AAAA,MAQA,SAAS,OAAO,QAAQ;AACpB,YAAI,OAAO,QAAQ,UAAU;AACzB,cAAI,IAAI,YAAY,QAAQ;AAExB,oBAAQ,IAAI,KAAK,cAAc;AAC/B,gBAAIC,SAAQ,MAAM,YAAY;AAE9B,gBAAI,IAAI;AAAU,sBAAQ,OAAO,IAAI,MAAM,IAAI,SAAS,oBAAoB,IAAI,QAAQ;AAAA,UAC5F;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACA;AACJ;AAEA,eAAe,OAAsB;AAGjC,QAAM,QAAQ,cAAc,mBAAmB,OAAO,IAAI;AAE1D,QAAM,UAAU,IAAI;AACpB,QAAM,WAAW;AACrB;AAOA,eAAe,aAAa;AACxB,UAAQ,IAAI,KAAK,YAAY;AAC7B,QAAM,OAAO,MAAM,iBAAiB;AACpC,QAAM,UAAU,IAAI;AACpB,MAAI,WAAW,QAAQ,UAAU,QAAQ,OAAO,WAAW,GAAG;AAE1D,cAAU,WAAW,YAAY,QAAQ,OAAO,WAAW,GAAI;AAAA,EACnE,OAAO;AACH,YAAQ,IAAI,aAAa;AAAA,EAC7B;AACJ;AAQA,eAAe,UAAU,MAAW;AAEhC,MAAI,WAAW,QAAQ,UAAU,MAAM,QAAQ,QAAQ,OAAO,KAAK,GAAG;AAClE,eAAW,QAAQ,QAAQ,OAAO,OAAO;AAErC,YAAM,SAAS,KAAK,GAAG,SAAS;AAEhC,UAAI,QAAQ,KAAK,eAAe,MAAM,GAAG;AACrC,YAAI;AACJ,YAAI,KAAK,SAAS,UAAU;AACxB,kBAAQ,WAAW,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,KAAK,UAAU;AAAA,QACnE,OAAO;AACH,kBAAQ,KAAK;AAAA,QACjB;AACA,cAAM,QAAQ,cAAc,KAAK,MAAM,EAAE,KAAK,OAAO,KAAK,KAAK,CAAC;AAAA,MACpE,OAAO;AACH,cAAM,QAAQ,wBAAwB,KAAK,MAAM;AAAA,UAC7C,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM,KAAK;AAAA,YACX,MAAM,KAAK;AAAA,YACX,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,YACP,MAAM,KAAK;AAAA,UACf;AAAA,UACA,QAAQ,CAAC;AAAA,QACb,CAAC;AAAA,MACL;AAAA,IAEJ;AAAA,EACJ;AACJ;AAOA,eAAe,mBAAmB;AAC9B,MAAI,OAAM,MAAM,QAAQ;AACxB,MAAI,CAAC,MAAM;AACP,YAAM,MAAM,YAAY;AACxB,WAAO,MAAM,QAAQ;AACrB,QAAG,CAAC;AAAM,aAAO;AAAA,EACrB;AACA,SAAO;AACX;AAMA,eAAe,cAA6B;AACxC,MAAI;AAEA,UAAM,OAAO,aAAa,QAAQ,OAAO,SAAS;AAClD,UAAM,UAAU;AAAA,MACZ,UAAU;AAAA,MACV,SAAS,QAAQ,OAAO;AAAA,MACxB,QAAQ,QAAQ,OAAO;AAAA,IAC3B;AACA,UAAM,cAAc,KAAK,MAAM,mBAAAC,QAAY,UAAU,OAAO,GAAG;AAAA,MAC3D,SAAS;AAAA,QACL,gBAAgB;AAAA,MACpB;AAAA,IACJ,CAAC;AAED,UAAM,OAAO,aAAa,QAAQ,OAAO,SAAS;AAClD,UAAM,WAAW,MAAM,cAAc,IAAI,IAAI;AAC7C,QAAI,QAAQ;AACZ,UAAM,QAAQ,SAAS,KAAK,MAAM,KAAK;AAEvC,QAAI,CAAC,OAAO;AACR,aAAO;AAAA,IACX;AAEA,WAAO,MAAM;AAAA,EAEjB,SAAS,OAAP;AACE,YAAQ,MAAM,KAAK;AACnB,WAAO;AAAA,EACX;AACJ;AAOA,eAAe,UAAmD;AAC9D,MAAI,CAAC,OAAO;AACR,UAAM,QAAQ,cAAc,mBAAmB,OAAO,IAAI;AAC1D,WAAO;AAAA,EACX;AAEA,QAAM,MAAM,aAAa,QAAQ,OAAO,SAAS,+CAA+C,QAAQ,OAAO,QAAQ,YAAY,QAAQ,OAAO,QAAQ;AAE1J,MAAI;AACA,UAAM,WAA0B,MAAM,cAAc,IAAI,KAAK;AAAA,MACzD,SAAS;AAAA,QACL,gBAAgB;AAAA,QAChB,oBAAoB;AAAA,MACxB;AAAA,IACJ,CAAC;AAED,QAAI,SAAS,WAAW,KAAK;AACzB,aAAO;AAAA,IACX;AAEA,UAAM,QAAQ;AACd,QAAI,QAAQ,MAAM,KAAK,SAAS,IAAI;AAEpC,UAAM,IAA6B,CAAC;AAEpC,WAAO,SAAS,MAAM;AAClB,QAAE,MAAM,MAAM,MAAM;AACpB,cAAQ,MAAM,KAAK,SAAS,IAAI;AAAA,IACpC;AACA,UAAM,QAAQ,cAAc,mBAAmB,MAAM,IAAI;AACzD,WAAO;AAAA,EACX,SAAS,OAAP;AACE,UAAM,QAAQ,cAAc,mBAAmB,OAAO,IAAI;AAC1D,YAAQ,MAAM,KAAK;AACnB,WAAO;AAAA,EACX;AACJ;AAGA,IAAI,QAAQ,SAAS,QAAQ;AAEzB,SAAO,UAAU;AACrB,OAAO;AAEH,eAAa;AACjB;",
  "names": ["axios", "token", "querystring"]
}
